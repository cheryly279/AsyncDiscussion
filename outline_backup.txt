- Asynchronous Primer

    - In the beginning...
        - When we first start programming, we learn how to code synchronously.
        - Every statement runs to completion, followed by the next statement in the control flow, until the application completes. [Primer/01_sync.js, Primer/02_sync_plus_wait.js]
        - Major downside: Slow! Results in a terrible user experience. The world doesn’t want to wait. And on the opposite side of the spectrum, for web apps we need to be able to wait, when the user is idle for some time before interacting with the page.
        - Basically, that tasks are NOT necessarily run in their control flow order - it is not known at runtime when certain portions of code will run.
    - What’s the big deal anyway?
        - Allows applications to be executed in a way that makes the most of the system's processing power.
        - Allows for event handling - the application can wait and respond to user events, such as clicking a button.
        - Application can run several actions at once (or seemingly at once), allowing for a richer experience even if some actions are slow.
        - Enables servers to handle more requests, and therefore more customers, without being blocked by slow I/O calls, for instance requests to a database.
    - How do systems run multiple actions at once?
        - Multithreading - Executing some work for a period of time, then switching to another task for some time, etc… An illusion of code running in parallel.
        - Multiprocessing - Executing different tasks on different processors, literally running code in parallel.
    - What does Javascript do?
        - Javascript allows for asynchronous programming in a single thread, using callbacks.
        - Under the hood, threads ARE used, but we don’t have to worry about this.
        - Instead we use callbacks - functions are passed as an argument to another function call, containing code that we want to run when the actions of the first function call have completed. (Can’t just do this by default, the main function needs to be defined to accept a callback.)
        - In the meantime, execution continues after the call to the first function. [Primer/03_async_timeout.js] TBD: Better example? With click events?
        - In some cases, there can be separate callbacks for the different ways we would want to handle the result of asynchronous code - the most common example is the success and failure callbacks. TBD: Write example.
        - For Javascript, this is implemented using an event loop.
            - Generally looks like this: (https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)

            - while(queue.waitForMessage()){
            -   queue.processNextMessage();
            - }

            - A function call is made, asking the runtime to perform some operation and also sending the callback to be run when the task completes.
            - The application can then continue to run.
            - When the earlier action completes, a message is added to the queue along with the callback.
                - Behind the scenes, some of these actions (for instance, reading data from a file), may be being executed in parallel using other threads and processes. But your Javascript code, and the event loop are still in a single main thread.
            - The event loop continually processes such messages, calling the callback functions as it goes.
        - Using a single thread this way makes coding easier - the developer doesn’t have to worry about sharing data between threads or how the different threads are accessing the system’s resources. The resulting code is also generally easier to read.
- Promises

    - But coding is always evolving. While using callbacks for asynchronous programming solves some problems, this coding style does still have it’s own downsides.
        - While easier to read than code with multiple threads, it is still not as easy to read and understand as synchronous code.
        - We cannot always pass separate callbacks for success and failure - instead, we have to check for errors in one callback.
        - We cannot simply return to a specific point of execution from a callback - if there is code that must execute after the asynchronous call, it must be wrapped in the callback, which can get large and unwieldy. This makes callback code seem more like “side-effects” of the application, rather than main functionality. TBD: Write example.
        - Multiple nested callbacks can result in the “pyramid of doom.” TBD: Write example.
    - Promises, which are new in ES6 Javascript 2015 ECMAScript 2015, are created to help solve these problems.
    - What are promises?
        - While they can seem confusing at first, they are basically a cleaner way of writing the same single-threaded asynchronous code we have been discussing. There’s no new “magic” on how Javascript asynchronous code works. It’s more like syntactic sugar. But it’s really good syntactic sugar, more like syntactic HFCS.
        - Promises allow us to treat the result of asynchronous code as a first-class citizen, similar to how Javascript allows us to pass functions around as arguments. We can now code in a way that is closer to how we would if we had the result synchronously - we can treat the promise itself as the result, even if the result is not complete yet.
        - Promises follow a standard, allowing us to be assured of what the callbacks are, and that only one will be called.
        - All of the above makes more sense once you start using the syntax (use funny gif here?).
    - Syntax for using promises (we will define our own shortly)
        - Where before we would pass the callback(s) as an argument (usually the final argument) to a function call, we now pass that code to handlers that are already attached to the promise - using the then function. TBD: Write example using then, where catch code is the second argument.
        - What about when the asynchronous operation causes an error? The then handler covers this as well - the callback function to handle failures is passed to then as the second argument. TBD: Write example with success and failure callbacks.
        - For convenience, Promises also have a catch handler. This is simply a shorthand for then(null, function()..). TBD: Write example using catch.
        - The asynchronous code runs whether the then/catch handlers are used or not.
        - Only one of the handlers will be called (success or failure), and the handler will only be called once.
        - At any given time, a promise is in one of three states:
            - Pending - the asynchronous code has not completed yet.
            - Fulfilled - the asynchronous code has completed successfully.
            - Rejected - the asynchronous code has failed.
        - Once the promise is fulfilled or rejected and the correct handler has been called, the promise is considered complete - the handlers will not be called again.
        - However, handlers can be added to the promise after it has been fulfilled or rejected, and the proper handler will still execute.
    - Chaining
        - A great feature of promises is that it allows us to break up and order asynchronous code that depends on earlier asynchronous code.
        - From a then or catch handler, we can execute other asynchronous operations. The results of this code can then be handled in a subsequent then or catch handler.
        - This is possible because the handlers themselves return a promise. TBD: Example! Question: What if a simple value is returned, is it turned into a promise? Also, mention good idea to always return something unless last then, because otherwise undefined is returned.
        - Some notes about the catch handler:
            - It’s good to end with a catch handler, as errors will flow down like in a try/catch block. If we don’t, any uncaught errors are simply lost.
            - The result of a catch that doesn’t throw another error is a resolved promise - is there a better way to explain this?
            - Using then and catch is NOT the same as using then with two callbacks - instead, catch is a handler for the next iteration of the chain. The upside of this is that errors from the previous then will be caught. When we instead call then with two callbacks, any new errors that come back from the first callback are not handled in the second callback. TBD: Example?
    - Take a step back - did this resolve the 4 issues above with callbacks? Go back through each issue in a slide.
    - Everything we have talked about so far has been about handling code that returns promises. But occasionally you are going to want to define your own promises, so that client code can handle your asynchronous function.
        - Syntax: new Promise(function(resolve, reject) {…});
        - In the function you pass to define the promise, you have the resolve and reject arguments. These are functions you can call to indicate that the work has completed successfully (using resolve) or not (using reject), and pass back a result or an error, respectively. TBD: Example defining a promise and also calling it.
        - Javascript also provides shorthand methods Promise.resolve and Promise.reject, for creating promises that are defined to simply resolve with a value or reject with a reason. These are shorthand for new Promise(function (resolve, reject) { resolve(value); }) and new Promise(function (resolve, reject) { reject(error); }). These methods come in handy for testing, or for converting code that is not asynchronous, or doesn’t conform to the promises standard to a promise that does conform to the promises standard.
    - Extra: Handling Several Concurrent Requests - Promise.all
        - In synchronous code, if you have list of values to manipulate, you can simply loop through each value and handle it appropriately. However, what if the handling of each value involves calling an asynchronous function? Remember that when an asynchronous function is called, it begins executing in parallel to the rest of the code. If we were to call an asynchronous function in each iteration of a loop, we would have n number of parallel actions occurring. More importantly, each one would need it’s own then to access the result.
        - Fortunately, the Promise object provides a way to wait for several promises to resolve - Promise.all. This function takes an array of promises and returns a promise that resolves when all the promises have resolved. Using the then handler will allow you to define a callback function that receives an array of results from the promises passed to all. TBD: Example.
        - Note that the promise resolves when/if all the promises passed resolve - if one fails, the entire promise fails.
    - How can I use them - do I need to have an es.js file? What browsers are they available for?
    - Different types of promises/terminology
        - The concept of promises isn’t new, and has been handled in different ways by different libraries. This has resulted, unfortunately, in confusing terminology and different types of promises.
        - What we have been discussing so far are promises defined for Javascript, fulfilling a specification known as the Promises/A+ specification: https://promisesaplus.com/.
        - Some terminology clarifiers:
            - Thenable - an object (usually a promise) that has a then function, allowing us to chain our handlers.
            - Future - simply an older term for promises.
            - Deferred - jQuery’s version of promises (focus of this part of the discussion). Note that a jQuery deferred object can be converted to a jQuery promise, which is still not the same as ES6 promises. Instead, these objects are like a subset of a deferred object, having fewer functions.
        - jQuery Deferreds
            - Unfortunately, deferreds do NOT fully conform to the A+ spec. Where possible, we should be using ES6-style promises instead.
            - Also unfortunately for us, jQuery is a core part of using Backbone, and deferred objects are returned from ajax calls, so for the time being they can be hard to avoid.
            - Deferreds were made available first, and so have a different set of states and functions, which can make handling them confusing, especially when they end up being used in conjunction with other asynchronous code. Brief rundown of methods:
                - then: takes callbacks for success, failure, or progress (runs based on progress notifications)
                - done: takes callback for success
                - fail: takes callback for failure
                - always: takes callback for success or failure
                - resolve, resolveWith: resolve the deferred
                - reject, rejectWith: reject the deferred
                - when: converts one or more objects to a promise, works similarly to Promise.all
                - promise: retrieve the deferred’s promise object
            - As well, deferreds are thenables, but the then handler does not return another deferred, so we cannot do the same chaining that is available with ES6-style promises.
- Fetch API
    - In addition to promises, ES6 also has a new API for performing AJAX requests, replacing XMLHttpRequest. ($.ajax is just a wrapper around this, right?)
    - While a lot of our front-end code uses $.ajax (or calls Backbone methods that use $.ajax), this won’t always be the case. It’s important to know about the new, cleaner API coming our way.
    - How does it work?
        - This API revolves largely around the fetch method on the window object. A simple way to use this method is to pass it a URL, which will execute a GET request.
        - Another way of using fetch is to pass a Request object, where you can specify the URL as well as configuration data, such as the request headers or the method of the request (GET, POST, etc.).
        - You can define and configure your own response with the Response object.

    - What are the benefits?
        - Returns promises - rather than having to remember to use the onload and onerror callbacks, we just use then/catch as we would with other promises.
        - The Request object makes it easier to configure the request, and copy the request to create other requests (cloning).
        - The response body can be streamed, rather than having the entire response in memory.
    - Downsides
        - You cannot (yet) abort a promise, so you cannot abort a request. You can, however, cancel a stream.
        - You cannot get progress events, to see how the request is going.
- Testing Asynchronous Code

    - Testing jquery-style promises.
    - Testing es6-style promises.
    - Brief mention of creating a fake server with Sinon.js. (Used in adminv2 express app)
- Async/Await

    - As we said earlier, coding style is always evolving. Promises are pretty awesome, but not without room for improvement.
    - Coming in ES7, we can make our code even cleaner using two new keywords: async and await. This feature allows us to write asynchronous code that looks even more like simple synchronous code.
    - Note: Async functions ==> used to be called defered functions.
    - Involves two keywords: async and await
    - The async keyword precedes the function definition/declaration. This wraps the function result in a promise, ensuring that the function returns a promise and can be used as such. If a value is returned the promise is resolved, if an error is thrown the promise is rejected. We no longer need to use calls to resolve and reject.
    - Once a function is marked as async, you can precede any asynchronous calls inside that function with await. This will force the function to wait until the asynchronous operation has completed. The resolved value or rejected error will be returned.
    - Note: Nested functions will also need the async keyword if they are going to be calling asynchronous operations.
    - Note: Using the await keyword before a call to synchronous code simply runs that code as it always would.
    - Maybe have an example with an inner function getting called multiple times to show things still happening in parallel?
    - await* or await Promise.all(…)?
    - You can use this feature if you are using the Traceur transpiler which converts ES6 to ES5 but with the option to add async/await. Maintained by Google. Does babel have this?
- Generators - Another way of doing asynchronous programming in ES6
    - A generator is a type of function whose execution can be paused and resumed later.
    - This can happen several times in a generator - not limited to one pause.
    - Why is this useful?
        - Can be used for iterating over a custom sequence. (example???)
        - Can be used to write asynchronous code in a more synchronous way. A generator can be used to hide away the asynchronous details, allowing the calling code to appear like synchronous code.
    - To make a function a generator, declare/define the function with an asterisk (function*). Can also move the asterisk to just before the function name, as in function *fun.
    - Use yield expressions to indicate where the function can be paused.
    - Generators execute as follows:
        - Call the function and assign the result to a variable (var x = fun()). This doesn’t start the execution of the generator, but instead creates something calling a generator iterator. We will use this object to run, or iterate, through the generator.
        - You call next() on the generator iterator to begin execution. The function will run until it encounters a yield expression. At this point, execution of the function is paused and control is passed back to the controller. If the yield keyword is followed by a value, that value is sent to the generator iterator. If this is left out, the value undefined is sent back.
        - The value that is sent back is wrapped in an object literal with two properties: value (the value returned), and done, a boolean indicating if the function has returned because it completed.
        - Something that is special about generators is that the communication goes both ways - a value is passed to the caller, AND the value sent to the next next call is passed BACK to the generator. This becomes the value that the yield expression evaluates to.
        - Note: Need to have final next() call after last yield to finish method. You can think of this in terms of the last yield expression not being complete yet - it has sent a value to a caller, but not received the value it’s going to evaluate to.
        - Note: You can pass a value into the first next call, but it is thrown away - since a yield expression has not yet been reached that will receive the value.
    - Besides the manual way of iterating through a generator, you can use the for/of structure. This structure allows you to loop through a generator very easily - the details of creating the generator iterator, and extracting the value returned from it’s wrapped object are abstracted away for you. The loop completes when done is true.
        - Note: When using generators this way, any value returned from a return statement at the end of the generator is lost. Instead, the final value you receive is the return value from the final yield. Also, no values can be passed back - there is only one-way communication when using for/of.
    - Catching errors from generators or inside generators is done with a simple try/catch block. Errors can be sent to generators by using the throw method in place of the next method.
    - Generators can “delegate” control to another iterator, where the generator iterator continues to iterate, but control passes to the other generator (and eventually back to the original generator when complete).
    - Using delegation, combined with promises, allows us to define async/await. - Show complex code, talk about libraries?
- Slide for good links!

    - Asynchronous Coding
    - Event loop
        - https://www.youtube.com/watch?v=8aGhZQkoFbQ
    - Promises
    - Async/Await
    - Generators
    - Other